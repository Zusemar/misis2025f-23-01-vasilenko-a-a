# Лабораторная работа №4: Сегментация

## Цель работы
Реализовать функционал сегментации изображений, визуализации результатов сегментации, создания эталона сегментации и оценки качества сегментации с использованием метрик для многоклассовой классификации.

---

## Часть 1. Сегментация изображения

### 1.1 K-means сегментация

Реализована функция:
```cpp
cv::Mat segment_kmeans(const cv::Mat& img, int K, int attempts = 3, 
                       cv::TermCriteria criteria = cv::TermCriteria(...));
```

Функция выполняет кластеризацию пикселей изображения методом K-means:
- Преобразует изображение в вектор признаков (пиксели как точки в пространстве цветов)
- Применяет алгоритм K-means для группировки пикселей в K кластеров
- Возвращает маску сегментации, где каждый пиксель содержит номер кластера (0..K-1)

**Параметры:**
- `K` — количество кластеров (сегментов)
- `attempts` — количество попыток с разными начальными центрами
- `criteria` — критерии остановки алгоритма

**Использование:**
```bash
./bin.rel/task04 part1 input_image.png output_dir/ 4
```

Результаты сохраняются в `output_dir/`:
- `segmentation_kmeans.png` — маска сегментации
- `segmentation_kmeans_visualized.png` — визуализация сегментации с наложением на исходное изображение

### 1.2 Watershed сегментация

Реализована функция:
```cpp
cv::Mat segment_watershed(const cv::Mat& img, const cv::Mat& markers);
```

Функция выполняет сегментацию методом watershed (водораздела):
- Использует маркеры для определения начальных регионов
- Применяет алгоритм watershed для разделения изображения на регионы
- Возвращает маску сегментации с номерами регионов

**Подготовка маркеров:**
1. Применяется адаптивная бинаризация для выделения объектов
2. Используются морфологические операции для очистки
3. Distance transform для определения гарантированных передних планов
4. Создаются маркеры: фон = 1, объекты = 2, 3, 4, ...

**Использование:**
Watershed сегментация выполняется автоматически в режиме `part1`.

Результаты:
- `segmentation_watershed.png` — маска сегментации
- `segmentation_watershed_visualized.png` — визуализация сегментации

### 1.3 Визуализация сегментации

Реализована функция:
```cpp
cv::Mat visualize_segmentation(const cv::Mat& segmentation_mask, 
                               const cv::Mat& original_img = cv::Mat(),
                               double overlay_alpha = 0.5);
```

Функция визуализирует результаты сегментации:
- Раскрашивает каждый сегмент случайным цветом
- Опционально накладывает сегментацию на исходное изображение с заданной прозрачностью

**Цветовая схема:**
- Каждый сегмент получает уникальный случайный цвет
- Цвета генерируются с использованием фиксированного seed для воспроизводимости

---

## Часть 2. Создание эталона сегментации

### 2.1 Генерация эталонной сегментации

Реализована функция генерации эталона:
```cpp
void part2_generate_ground_truth(const std::string& input_path, 
                                 const std::string& output_dir);
```

**Метод создания эталона:**
1. **Анализ яркости:** Разделение изображения на классы по уровням яркости:
   - Класс 1 (фон): темные области (яркость < 50)
   - Класс 2 (скорлупа): средние значения (50 ≤ яркость < 150)
   - Класс 3 (ядро): светлые области (яркость ≥ 150)

2. **Комбинация с K-means:** Используются результаты K-means сегментации для улучшения эталона в областях с неоднозначной классификацией

3. **Результат:** Создается эталонная маска с 3 классами

**Использование:**
```bash
./bin.rel/task04 part2 input_image.png output_dir/
```

Результаты:
- `ground_truth_segmentation.png` — эталонная маска сегментации
- `ground_truth_visualized.png` — визуализация эталона

**Примечание:** Эталон можно дополнительно улучшить вручную с помощью графических редакторов для более точной разметки.

---

## Часть 3. Оценка качества сегментации

### 3.1 Метрики многоклассовой сегментации

Реализована структура для хранения метрик:
```cpp
struct SegmentationMetrics {
    int num_classes;
    std::vector<int> class_ids;
    
    // Для каждого класса
    std::vector<int> TP, FP, FN;
    std::vector<double> Precision, Recall, IoU, F1;
    
    // Общие метрики
    double OverallAccuracy;
    double MeanIoU;
    double MeanF1;
};
```

**Метрики для каждого класса:**
- **TP (True Positive)** — пиксели, правильно классифицированные как данный класс
- **FP (False Positive)** — пиксели, ошибочно классифицированные как данный класс
- **FN (False Negative)** — пиксели данного класса, ошибочно классифицированные как другой класс

**Вычисляемые метрики:**
- **Precision** = TP / (TP + FP) — точность классификации класса
- **Recall** = TP / (TP + FN) — полнота обнаружения класса
- **IoU (Intersection over Union)** = TP / (TP + FP + FN) — пересечение над объединением
- **F1-score** = 2 × (Precision × Recall) / (Precision + Recall) — гармоническое среднее

**Общие метрики:**
- **Overall Accuracy** — общая точность классификации всех пикселей
- **Mean IoU** — средний IoU по всем классам
- **Mean F1** — средний F1-score по всем классам

### 3.2 Вычисление метрик

Реализована функция:
```cpp
SegmentationMetrics calc_segmentation_metrics(const cv::Mat& predicted_segmentation,
                                              const cv::Mat& ground_truth_segmentation);
```

Функция:
1. Находит все уникальные классы в обеих сегментациях
2. Для каждого класса вычисляет TP, FP, FN
3. Вычисляет все метрики для каждого класса
4. Вычисляет общие метрики

### 3.3 Визуализация ошибок

Реализована функция:
```cpp
cv::Mat visualize_segmentation_errors(const cv::Mat& predicted, 
                                     const cv::Mat& ground_truth,
                                     const cv::Mat& original_img = cv::Mat(),
                                     double overlay_alpha = 0.3);
```

Функция создает визуализацию ошибок сегментации с цветовой кодировкой:
- **Зеленый** — правильно сегментированные пиксели
- **Красный** — ложные срабатывания (FP)
- **Синий** — пропущенные пиксели (FN)
- **Желтый** — неправильная классификация (разные классы)

### 3.4 Использование

**Использование:**
```bash
./bin.rel/task04 part3 input_image.png ground_truth.png output_dir/ 4
```

**Результаты:**
- `segmentation_metrics.csv` — таблица метрик для всех классов
- `segmentation_errors.png` — визуализация ошибок
- `predicted_segmentation.png` — предсказанная сегментация
- `predicted_segmentation_visualized.png` — визуализация предсказания

**Формат CSV:**
```
Class_ID,TP,FP,FN,Precision,Recall,IoU,F1
1,206918,0,0,1.0000,1.0000,1.0000,1.0000
2,36741,0,0,1.0000,1.0000,1.0000,1.0000
3,7342,0,0,1.0000,1.0000,1.0000,1.0000

Overall Metrics
OverallAccuracy,MeanIoU,MeanF1
1.0000,1.0000,1.0000
```

---

## Сборка и использование

### Сборка
```bash
cmake --build /Users/alex/Documents/misis2025f-23-01-vasilenko-a-a/build --config Release -j
```

Исполняемый файл появляется в `build/prj.lab/lab04/task04`.

### Примеры использования

**Часть 1 (Сегментация):**
```bash
./build/prj.lab/lab04/task04 part1 input.png output/ 4
```

**Часть 2 (Генерация эталона):**
```bash
./build/prj.lab/lab04/task04 part2 input.png output/
```

**Часть 3 (Оценка качества):**
```bash
./build/prj.lab/lab04/task04 part3 input.png ground_truth.png output/ 4
```

---

## Реализованные функции в библиотеке semcv

### Функции сегментации:
1. `segment_kmeans()` — K-means сегментация
2. `segment_watershed()` — Watershed сегментация
3. `visualize_segmentation()` — визуализация сегментации
4. `visualize_segmentation_errors()` — визуализация ошибок

### Функции оценки качества:
1. `calc_segmentation_metrics()` — вычисление метрик сегментации
2. `SegmentationMetrics` — структура для хранения метрик

---

## Анализ результатов

### K-means сегментация

**Преимущества:**
- Простота реализации и использования
- Быстрое выполнение
- Хорошо работает для изображений с четкими цветовыми различиями между объектами

**Недостатки:**
- Требует знания количества кластеров заранее
- Чувствителен к начальным центрам кластеров
- Может неправильно сегментировать объекты с плавными переходами цветов

### Watershed сегментация

**Преимущества:**
- Хорошо работает для разделения близко расположенных объектов
- Использует информацию о границах объектов
- Может обрабатывать сложные формы объектов

**Недостатки:**
- Требует качественных маркеров
- Чувствителен к шуму
- Может создавать пересегментацию (слишком много регионов)

### Сравнение методов

Для изображения ореха (walnut):
- **K-means** лучше выделяет основные регионы (фон, скорлупа, ядро) на основе цветовых различий
- **Watershed** лучше разделяет границы между объектами, но требует более тщательной подготовки маркеров

### Метрики качества

При использовании автоматически сгенерированного эталона метрики показывают высокие значения, так как эталон создается на основе тех же методов, что и предсказание. Для более объективной оценки необходимо использовать эталон, созданный вручную экспертом.

---

## Выводы

1. Реализован полный функционал сегментации изображений с использованием двух методов: K-means и Watershed
2. Создана система визуализации результатов сегментации и ошибок
3. Реализована система оценки качества сегментации с использованием метрик многоклассовой классификации
4. Разработан метод автоматической генерации эталона сегментации
5. Проведен анализ результатов сегментации для изображения ореха

**Лабораторная работа №4 выполнена успешно.**


